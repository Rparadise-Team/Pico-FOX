#!/bin/sh

export LOCK_FILE="/var/lock/_resize_partition"
export TMP_PATH="/tmp/fatresize"
export TMP_LIB="/tmp/fatresize/lib"

# Function to kill processes that might block the partition
task_killer() {
    r=0
    for p in $1; do
        if [ -d "/proc/$p" ] && [ $p -ne $$ ]; then
            kill $2 $p
            r=1
        fi
    done
    return $r
}

# Attempt to kill processes that are using the partition
kill_hooked_tasks() {
    c=0
    while [ $c -lt 5 ]; do
        pids=$(fuser -m /mnt/SDCARD 2>/dev/null)
        if task_killer "$pids" $1; then
            return
        fi
        sleep 0.05
        c=$((c + 1))
    done
}

# Check if the script is already running
if [ "$0" = "/tmp/_resize_partition" ]; then
    if [ ! -f "$LOCK_FILE" ]; then
        touch "$LOCK_FILE"
    else
        echo "resize_partition is already running."
        exit 1
    fi

    # Kill processes that could be blocking the SD
    echo "Terminating processes that are blocking the partition..."
    killall -9 updater 2>/dev/null
    sleep 1
    kill_hooked_tasks
    sleep 0.1
    kill_hooked_tasks -9

    sync

    # Unmount the partition and disable swap
    echo "Unmounting the partition..."
    swapoff /mnt/SDCARD/cachefile 2>/dev/null
    umount -r /mnt/SDCARD 2>/dev/null
    umount /mnt/SDCARD 2>/dev/null

    # Prepare the environment for running fatresize
    echo "Preparing environment for fatresize..."
    export LD_LIBRARY_PATH=$TMP_LIB:/lib:/config/lib:/customer/lib:$LD_LIBRARY_PATH

    # Ensure that the fatresize binary is executable
    chmod +x $TMP_PATH
	
	$TMP_PATH/show $TMP_PATH/resize.png

    # Show partition information before resizing
    echo "Partition information before resizing:"
    $TMP_PATH/fdisk -l /dev/mmcblk0

    # Get disk and partition details using fdisk
    echo "Getting disk and partition information..."
    TOTAL_SECTORS=$($TMP_PATH/fdisk -l /dev/mmcblk0 | grep "sectors$" | awk '{print $7}')
    PART_START=$($TMP_PATH/fdisk -l /dev/mmcblk0 | grep "/dev/mmcblk0p1" | awk '{print $2}')

    if [ -z "$TOTAL_SECTORS" ] || [ -z "$PART_START" ]; then
        echo "Error: Unable to retrieve disk or partition information."
		sync
		/customer/main
        exit 1
    fi

    SECTOR_SIZE=512  # Sector size in bytes

    # Leave a small margin at the end of the partition (1MB)
    MARGIN_SECTORS=$((1 * 1024 * 1024 / SECTOR_SIZE))  # 1MB in sectors
    MAX_SECTORS=$((TOTAL_SECTORS - PART_START - MARGIN_SECTORS))

    # Calculate maximum partition size in MB
    MAX_PART_SIZE_MB=$((MAX_SECTORS * SECTOR_SIZE / 1048576))

    echo "Total disk size: $((TOTAL_SECTORS * SECTOR_SIZE / 1048576)) MB"
    echo "Max partition size with 1MB margin: ${MAX_PART_SIZE_MB} MB"

    # Run fatresize with the calculated size
    echo "Resizing the FAT32 partition to ${MAX_PART_SIZE_MB}MB..."
    $TMP_PATH/fatresize -f -v -s ${MAX_PART_SIZE_MB}M /dev/mmcblk0p1

    # Check if the resize was successful
    if [ $? -ne 0 ]; then
        echo "Error resizing the partition."
        sync
		/customer/main
        exit 1
    fi

    # Run partprobe to force partition table reload
    echo "Forcing partition table reload with partprobe..."
    $TMP_PATH/partprobe /dev/mmcblk0

    # Fix FAT32 header
    echo -n -e \\xEB\\x58\\x90 > /dev/mmcblk0p1
    sync

    # Remount the partition using system's mount command
    echo "Remounting the partition..."
    mount /dev/mmcblk0p1 /mnt/SDCARD

    # Show partition information after resizing
    echo "Partition information after resizing:"
    $TMP_PATH/fdisk -l /dev/mmcblk0

    # Create a file indicating that the resize has been completed
    touch /mnt/SDCARD/resized

    # Sync changes before rebooting
    sync

    echo "Unmounting the partition..."
    umount -r /mnt/SDCARD
    umount /mnt/SDCARD

    sync

    echo "Resizing completed. Rebooting the system..."
	if [ ! -f "/customer/app/axp_test" ]; then
    	reboot
	else
		poweroff
	fi
fi

# Check if the script is copied to /tmp, if not, copy it
if [ ! -f /tmp/_resize_partition ]; then
    cp -f "$0" /tmp/_resize_partition
fi

# Run the script independently in the background
pgrep -f /tmp/_resize_partition || (
    set -m
    su root -c "/usr/bin/nohup /tmp/_resize_partition $1 </dev/null >/dev/null 2>&1 &"
)

# Wait to prevent the main script from closing immediately
while true; do
    sleep 10
done
